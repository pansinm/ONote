# ONote 代码规范

## 目录

- [TypeScript 编码规范](#typescript-编码规范)
- [React 组件规范](#react-组件规范)
- [MobX 状态管理规范](#mobx-状态管理规范)
- [命名规范](#命名规范)
- [代码组织](#代码组织)
- [注释规范](#注释规范)
- [错误处理](#错误处理)
- [性能优化](#性能优化)

---

## TypeScript 编码规范

### 基本原则

1. **优先使用 const**
   ```typescript
   // ✅ 推荐
   const MAX_COUNT = 100;
   const apiUrl = 'https://api.example.com';

   // ❌ 避免
   var maxCount = 100;
   let API_URL = 'https://api.example.com';
   ```

2. **明确类型定义**
   ```typescript
   // ✅ 推荐 - 明确类型
   interface User {
     id: string;
     name: string;
     age: number;
   }

   function processUser(user: User): void {
     // ...
   }

   // ❌ 避免 - 使用 any
   function processUser(user: any): void {
     // ...
   }
   ```

3. **使用可选链和空值合并**
   ```typescript
   // ✅ 推荐
   const name = user?.profile?.name ?? 'Anonymous';
   const count = items?.length ?? 0;

   // ❌ 避免
   const name = user && user.profile && user.profile.name || 'Anonymous';
   ```

4. **避免使用 any**
   ```typescript
   // ✅ 推荐
   function processData(data: unknown): string {
     if (typeof data === 'string') {
       return data;
     }
     return String(data);
   }

   // ❌ 避免
   function processData(data: any): string {
     return data;
   }
   ```

### 接口和类型

1. **接口命名使用 PascalCase**
   ```typescript
   // ✅ 推荐
   interface UserProfile {
     id: string;
     name: string;
   }

   interface ApiResponse<T> {
     data: T;
     status: number;
   }

   // ❌ 避免
   interface userProfile {
     // ...
   }
   ```

2. **类型别名用于联合类型**
   ```typescript
   // ✅ 推荐
   type Theme = 'light' | 'dark' | 'auto';
   type ID = string | number;

   // ❌ 避免
   interface Theme {
     // 联合类型不应该用 interface
   }
   ```

3. **使用 readonly 保护不可变数据**
   ```typescript
   // ✅ 推荐
   interface Config {
     readonly version: string;
     readonly buildTime: Date;
     debug: boolean;
   }

   // ❌ 避免
   interface Config {
     version: string;  // 应该是只读
     buildTime: Date;  // 应该是只读
   }
   ```

### 函数

1. **函数参数使用解构**
   ```typescript
   // ✅ 推荐
   function createUser({ name, email, age = 18 }: {
     name: string;
     email: string;
     age?: number;
   }) {
     // ...
   }

   // ❌ 避免
   function createUser(options: { name: string; email: string; age?: number }) {
     const name = options.name;
     const email = options.email;
     // ...
   }
   ```

2. **异步函数返回 Promise 类型**
   ```typescript
   // ✅ 推荐
   async function fetchUser(id: string): Promise<User> {
     const response = await fetch(`/api/users/${id}`);
     return response.json();
   }

   // ❌ 避免
   async function fetchUser(id: string) {
     // 缺少返回类型
   }
   ```

3. **错误处理**
   ```typescript
   // ✅ 推荐
   async function loadData(): Promise<Data | null> {
     try {
       const response = await fetch(url);
       return await response.json();
     } catch (error) {
       console.error('Failed to load data:', error);
       return null;
     }
   }

   // ❌ 避免 - 吞掉错误
   async function loadData(): Promise<Data | null> {
     try {
       const response = await fetch(url);
       return await response.json();
     } catch (error) {
       // 空的 catch
     }
   }
   ```

---

## React 组件规范

### 组件定义

1. **使用函数组件**
   ```typescript
   // ✅ 推荐
   const MyComponent: FC<Props> = ({ title, onAction }) => {
     return <div>{title}</div>;
   };

   // ❌ 避免 - 不再使用类组件
   class MyComponent extends Component<Props, State> {
     // ...
   }
   ```

2. **Props 接口定义**
   ```typescript
   // ✅ 推荐 - 明确 Props 接口
   interface ButtonProps {
     label: string;
     onClick: () => void;
     disabled?: boolean;
   }

   const Button: FC<ButtonProps> = ({ label, onClick, disabled = false }) => {
     return <button onClick={onClick} disabled={disabled}>{label}</button>;
   };

   // ❌ 避免 - 直接使用 inline 类型
   const Button: FC<{ label: string; onClick: () => void }> = ({ label, onClick }) => {
     return <button onClick={onClick}>{label}</button>;
   };
   ```

### Hooks 使用

1. **自定义 Hook 命名**
   ```typescript
   // ✅ 推荐 - use 前缀
   function useUserData(userId: string) {
     const [user, setUser] = useState<User | null>(null);
     // ...
     return user;
   }

   // ❌ 避免
   function getUserData(userId: string) {
     // 缺少 use 前缀
   }
   ```

2. **依赖项数组**
   ```typescript
   // ✅ 推荐 - 完整的依赖项
   useEffect(() => {
     fetchData(userId, filters);
   }, [userId, filters]);  // 所有使用的变量都在依赖数组中

   // ❌ 避免 - 缺少依赖项
   useEffect(() => {
     fetchData(userId, filters);
   }, []);  // 缺少 userId 和 filters
   ```

3. **清理副作用**
   ```typescript
   // ✅ 推荐 - 清理订阅
   useEffect(() => {
     const subscription = subscribe(event);
     return () => {
       subscription.unsubscribe();
     };
   }, [event]);

   // ❌ 避免 - 没有清理
   useEffect(() => {
     subscribe(event);
   }, [event]);  // 内存泄漏风险
   ```

### 组件组织

1. **导入顺序**
   ```typescript
   // ✅ 推荐 - 按顺序导入
   // 1. React 相关
   import React, { FC, useEffect } from 'react';

   // 2. 第三方库
   import { observer } from 'mobx-react-lite';
   import { Button } from '@fluentui/react-components';

   // 3. 内部组件
   import { Header } from './Header';
   import { Footer } from './Footer';

   // 4. 类型
   import type { AppProps } from './types';

   // 5. 样式
   import styles from './App.module.scss';

   // 6. 工具函数
   import { formatDate } from '/@/common/utils';
   ```

2. **组件结构**
   ```typescript
   // ✅ 推荐 - 标准组件结构
   const MyComponent: FC<MyComponentProps> = ({ prop1, prop2 }) => {
     // 1. Hooks
     const [state, setState] = useState();
     const store = useStore();

     // 2. 派生状态
     const derivedValue = useMemo(() => {
       return compute(state);
     }, [state]);

     // 3. 事件处理函数
     const handleClick = useCallback(() => {
       // 处理逻辑
     }, []);

     // 4. 副作用
     useEffect(() => {
       // 副作用
     }, []);

     // 5. 渲染
     return (
       <div>
         {/* JSX */}
       </div>
     );
   };
   ```

---

## MobX 状态管理规范

### Store 定义

1. **使用 makeAutoObservable**
   ```typescript
   // ✅ 推荐
   import { makeAutoObservable, runInAction } from 'mobx';

   class UserStore {
     users: User[] = [];
     loading = false;

     constructor() {
       makeAutoObservable(this);
     }

     async loadUsers() {
       this.loading = true;
       const data = await api.getUsers();
       runInAction(() => {
         this.users = data;
         this.loading = false;
       });
     }
   }

   // ❌ 避免 - 使用 makeObservable（繁琐）
   class UserStore {
     users: User[] = [];

     constructor() {
       makeObservable(this, {
         users: observable,
         loadUsers: action,
       });
     }
   }
   ```

2. **使用 runInAction 包裹异步状态更新**
   ```typescript
   // ✅ 推荐
   async loadData() {
     const data = await fetchData();
     runInAction(() => {
       this.items = data;
       this.loading = false;
     });
   }

   // ❌ 避免 - 直接更新
   async loadData() {
     const data = await fetchData();
     this.items = data;  // 在 async 函数中直接更新
   }
   ```

### 在组件中使用

1. **使用 observer 包裹组件**
   ```typescript
   // ✅ 推荐
   import { observer } from 'mobx-react-lite';

   const UserList: FC = observer(() => {
     const { userStore } = stores;
     return <div>{userStore.users.length}</div>;
   });

   // ❌ 避免 - 忘记 observer
   const UserList: FC = () => {
     const { userStore } = stores;
     return <div>{userStore.users.length}</div>;
   };  // 不会自动更新
   ```

2. **避免直接解构 observable**
   ```typescript
   // ✅ 推荐 - 不解构
   const UserList: FC = observer(() => {
     const { userStore } = stores;
     return <div>{userStore.users.length}</div>;
   });

   // ❌ 避免 - 解构失去响应性
   const UserList: FC = observer(() => {
     const { users } = stores.userStore;  // 解构了 observable
     return <div>{users.length}</div>;
   });  // 不会响应更新
   ```

---

## 命名规范

### 文件命名

1. **组件文件使用 PascalCase**
   ```
   ✅ 推荐
   UserProfile.tsx
   DataTable.tsx
   Header.tsx

   ❌ 避免
   userProfile.tsx
   data-table.tsx
   header_component.tsx
   ```

2. **工具文件使用 kebab-case**
   ```
   ✅ 推荐
   date-utils.ts
   api-helper.ts
   string-formatter.ts

   ❌ 避免
   dateUtils.ts
   api_helper.ts
   StringFormatter.ts
   ```

3. **Store 文件使用 XStore 模式**
   ```
   ✅ 推荐
   UserStore.ts
   SettingStore.ts
   LayoutStore.ts

   ❌ 避免
   user.ts
   settings.ts
   layout.ts
   ```

### 变量命名

1. **布尔值使用 is/has 前缀**
   ```typescript
   // ✅ 推荐
   const isVisible = true;
   const hasPermission = false;
   const canEdit = true;
   const isLoading = false;

   // ❌ 避免
   const visible = true;
   const permission = false;
   ```

2. **函数使用动词开头**
   ```typescript
   // ✅ 推荐
   function getUserData() { }
   function handleSubmit() { }
   function calculateTotal() { }

   // ❌ 避免
   function userData() { }
   function submit() { }
   function total() { }
   ```

3. **常量使用 UPPER_SNAKE_CASE**
   ```typescript
   // ✅ 推荐
   const MAX_RETRY_COUNT = 3;
   const DEFAULT_PAGE_SIZE = 20;
   const API_BASE_URL = 'https://api.example.com';

   // ❌ 避免
   const maxRetryCount = 3;
   const default_page_size = 20;
   const apiBaseUrl = 'https://api.example.com';
   ```

---

## 代码组织

### 目录结构

```
src/
├── components/          # 通用组件
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.module.scss
│   │   └── index.ts
│   └── ...
├── containers/          # 容器组件
├── stores/             # MobX stores
├── services/           # API 服务
├── utils/              # 工具函数
├── types/              # 类型定义
├── constants/          # 常量
└── styles/             # 全局样式
```

### 导出方式

1. **命名导出优先**
   ```typescript
   // utils.ts
   export function formatDate(date: Date) { }
   export function formatTime(date: Date) { }

   // 使用
   import { formatDate, formatTime } from './utils';

   // ✅ 推荐 - 清晰的命名导出
   ```

2. **默认导出用于组件**
   ```typescript
   // Button.tsx
   const Button: FC<ButtonProps> = (props) => { };
   export default Button;

   // 使用
   import Button from './Button';

   // ✅ 推荐 - 组件使用默认导出
   ```

---

## 注释规范

### JSDoc 注释

1. **函数必须添加 JSDoc**
   ```typescript
   /**
    * 计算两个日期之间的天数差
    * @param date1 - 第一个日期
    * @param date2 - 第二个日期
    * @returns 天数差
    * @throws {Error} 如果日期无效
    *
    * @example
    * ```typescript
    * const days = daysBetween(new Date('2024-01-01'), new Date('2024-01-10'));
    * console.log(days); // 9
    * ```
    */
   function daysBetween(date1: Date, date2: Date): number {
     // 实现
   }
   ```

2. **接口注释**
   ```typescript
   /**
    * 用户配置选项
    */
   interface UserOptions {
     /**
      * 用户名
      */
     name: string;

     /**
      * 用户年龄，必须大于 0
      */
     age: number;

     /**
      * 是否启用通知功能，默认为 true
      */
     notificationsEnabled?: boolean;
   }
   ```

### 代码注释

1. **解释"为什么"而不是"做什么"**
   ```typescript
   // ✅ 推荐 - 解释原因
   // 使用 setTimeout 避免阻塞 UI 线程
   setTimeout(() => {
     processLargeData();
   }, 0);

   // ❌ 避免 - 只是重复代码
   // 设置超时为 0
   setTimeout(() => {
     processLargeData();
   }, 0);
   ```

2. **标记 TODO 和 FIXME**
   ```typescript
   // TODO: 添加输入验证
   function saveUser(user: User) {
     api.save(user);
   }

   // FIXME: 这里存在内存泄漏，需要清理订阅
   useEffect(() => {
     subscribe(event);
   }, []);
   ```

---

## 错误处理

### 异常捕获

1. **始终捕获可能的异常**
   ```typescript
   // ✅ 推荐
   async function loadConfig() {
     try {
       const config = await readConfigFile();
       return config;
     } catch (error) {
       console.error('Failed to load config:', error);
       return getDefaultConfig();  // 返回默认值
     }
   }

   // ❌ 避免 - 没有错误处理
   async function loadConfig() {
     const config = await readConfigFile();
     return config;
   }
   ```

2. **使用类型保护**
   ```typescript
   // ✅ 推荐
   function isUser(value: unknown): value is User {
     return (
       typeof value === 'object' &&
       value !== null &&
       'id' in value &&
       'name' in value
     );
   }

   if (isUser(data)) {
     console.log(data.name);  // 类型安全
   }
   ```

---

## 性能优化

### React 性能

1. **使用 useMemo 缓存计算结果**
   ```typescript
   // ✅ 推荐
   const sortedList = useMemo(() => {
     return list.sort((a, b) => a.id - b.id);
   }, [list]);

   // ❌ 避免 - 每次渲染都重新计算
   const sortedList = list.sort((a, b) => a.id - b.id);
   ```

2. **使用 useCallback 缓存函数**
   ```typescript
   // ✅ 推荐
   const handleClick = useCallback(() => {
     console.log('Clicked');
   }, []);

   // ❌ 避免 - 每次渲染都创建新函数
   const handleClick = () => {
     console.log('Clicked');
   };
   ```

3. **避免不必要的渲染**
   ```typescript
   // ✅ 推荐 - 使用 React.memo
   const ExpensiveComponent = memo(({ data }) => {
     return <div>{/* 复杂渲染 */}</div>;
   });

   // ❌ 避免 - 每次父组件更新都重新渲染
   const ExpensiveComponent = ({ data }) => {
     return <div>{/* 复杂渲染 */}</div>;
   };
   ```

### 列表渲染

1. **使用唯一的 key**
   ```typescript
   // ✅ 推荐 - 使用唯一标识
   {users.map(user => (
     <UserItem key={user.id} user={user} />
   ))}

   // ❌ 避免 - 使用索引作为 key
   {users.map((user, index) => (
     <UserItem key={index} user={user} />
   ))}
   ```

---

## ESLint 配置

项目使用 ESLint 进行代码检查，配置文件位于项目根目录。

运行检查：
```bash
yarn lint
```

自动修复：
```bash
yarn lint --fix
```

---

## 代码审查清单

提交代码前，请确认：

- [ ] 代码通过 ESLint 检查
- [ ] 所有函数都有 JSDoc 注释
- [ ] 没有 `any` 类型（除非必要）
- [ ] 没有调试代码（console.log、debugger）
- [ ] 错误被正确处理
- [ ] 组件有明确的 Props 类型
- [ ] MobX Store 使用 `runInAction` 更新状态
- [ ] 没有硬编码的常量
- [ ] 命名符合规范
- [ ] 代码有适当的注释

---

## 参考资源

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [React Documentation](https://react.dev/)
- [MobX Documentation](https://mobx.js.org/)
- [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)
- [Airbnb React/JSX Style Guide](https://github.com/airbnb/javascript/tree/master/react)

---

## 更新日期

最后更新：2025-01-04
