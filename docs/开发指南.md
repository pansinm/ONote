# ONote 开发指南

## 目录

- [环境准备](#环境准备)
- [项目搭建](#项目搭建)
- [开发工作流](#开发工作流)
- [调试技巧](#调试技巧)
- [常用开发任务](#常用开发任务)
- [测试](#测试)
- [构建与发布](#构建与发布)
- [常见问题](#常见问题)

---

## 环境准备

### 系统要求

- **操作系统**: Windows 10+, macOS 10.15+, 或 Linux
- **Node.js**: 推荐使用 Node.js 18.x 或更高版本
- **Yarn**: 1.22.x 或更高版本
- **Git**: 2.0 或更高版本

### 必需软件

1. **Node.js**
   ```bash
   # 检查 Node.js 版本
   node --version  # 推荐 v18.x 或更高
   ```

   下载地址: https://nodejs.org/

2. **Yarn**
   ```bash
   # 安装 Yarn
   npm install -g yarn

   # 检查 Yarn 版本
   yarn --version
   ```

3. **Git**
   ```bash
   # 检查 Git 版本
   git --version
   ```

4. **推荐 IDE**
   - Visual Studio Code (推荐)
   - WebStorm
   - 其他支持 TypeScript 的编辑器

### VS Code 推荐插件

如果使用 VS Code，推荐安装以下插件：

- ESLint
- Prettier
- Error Lens
- Material Icon Theme
- GitLens
- Thunder Client (用于测试 API)

---

## 项目搭建

### 1. 克隆仓库

```bash
# 克隆项目
git clone https://github.com/your-org/ONote.git
cd ONote
```

### 2. 安装依赖

ONote 使用 Yarn Workspaces 管理 monorepo 依赖。

```bash
# 安装所有依赖
yarn install
```

**依赖安装说明：**

- 根目录的 `node_modules` 包含共享依赖
- 每个 package 也有自己的 `node_modules`
- Yarn 会自动提升公共依赖到根目录

### 3. 项目结构理解

安装完成后，项目目录结构如下：

```
ONote/
├── packages/
│   ├── electron/          # 主进程
│   ├── renderer/          # 渲染进程
│   └── shared/            # 共享代码
├── buildResources/        # 构建资源
├── docs/                  # 文档
├── node_modules/          # 依赖
├── package.json           # 根 package.json
├── turbo.json             # Turborepo 配置
├── tsconfig.json          # TypeScript 配置
└── [其他配置文件]
```

---

## 开发工作流

### 启动开发模式

```bash
# 启动开发服务器（支持热更新）
yarn dev
```

这个命令会：
1. 启动 Electron 主进程
2. 启动 Webpack 开发服务器（渲染进程）
3. 启用热模块替换（HMR）
4. 自动编译 TypeScript

### 代码修改后

- **渲染进程代码修改**: 自动热更新
- **主进程代码修改**: 需要手动重启应用（Ctrl+R 或 Cmd+R）
- **样式文件修改**: 自动热更新

### 开发模式特性

- React Developer Tools 自动启用
- 详细的错误日志
- Source Maps 支持
- 快速重新编译

### Git 工作流

1. **创建功能分支**
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. **提交代码**
   ```bash
   git add .
   git commit -m "feat: 添加新功能描述"
   ```

3. **推送分支**
   ```bash
   git push origin feature/your-feature-name
   ```

4. **创建 Pull Request**
   在 GitHub 上创建 PR，等待代码审查

---

## 调试技巧

### 1. 渲染进程调试

渲染进程运行在 Chromium 中，可以使用 Chrome DevTools。

**打开 DevTools:**
- 开发模式自动打开
- 或使用快捷键：
  - Windows/Linux: `Ctrl + Shift + I`
  - macOS: `Cmd + Option + I`

**主要功能:**
- Elements: 查看 DOM 结构
- Console: 查看日志和错误
- Network: 监控网络请求
- Sources: 设置断点调试
- Performance: 性能分析

### 2. 主进程调试

**使用 VS Code 调试:**

1. 创建 `.vscode/launch.json`:
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Main Process",
      "type": "node",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "runtimeExecutable": "${workspaceFolder}/node_modules/.bin/electron",
      "windows": {
        "runtimeExecutable": "${workspaceFolder}/node_modules/.bin/electron.cmd"
      },
      "args": ["."],
      "outputCapture": "std"
    }
  ]
}
```

2. 在主进程代码中设置断点
3. 按 F5 启动调试

**查看主进程日志:**
- 主进程的 console.log 会显示在终端
- VS Code 的 Debug Console 中也可以看到

### 3. IPC 通信调试

**查看 IPC 消息:**

在主进程中添加日志：
```typescript
// packages/electron/src/ipc-server/IPCServer.ts
ipcMain.handle('namespace.method', async (event, ...args) => {
  console.log('IPC Call:', { namespace, method, args });
  // ...
});
```

在渲染进程中添加日志：
```typescript
const result = await ipcRenderer.invoke('namespace.method', ...args);
console.log('IPC Result:', result);
```

### 4. 性能调试

**使用 React DevTools:**
- 安装 React Developer Tools 浏览器插件
- 开发模式会自动加载
- 查看 Component 渲染性能
- 分析 MobX Store 状态

**使用 Chrome Performance 标签:**
1. 打开 DevTools Performance 标签
2. 点击 Record
3. 执行操作
4. 停止录制并分析

### 5. 内存调试

**使用 Memory 标签:**
1. 打开 DevTools Memory 标签
2. 拍摄堆快照 (Heap Snapshot)
3. 执行操作
4. 再次拍摄快照
5. 对比两个快照，查找内存泄漏

---

## 常用开发任务

### 添加新的 IPC 方法

#### 1. 在主进程定义 Handler

```typescript
// packages/electron/src/ipc-server/handlers/YourHandler.ts
import { IpcInvokeEvent } from 'electron';

export class YourHandler {
  async yourMethod(event: IpcInvokeEvent, param1: string) {
    // 实现逻辑
    return 'result';
  }
}
```

#### 2. 注册 Handler

```typescript
// packages/electron/src/ipc-server/index.ts
import { YourHandler } from './handlers/YourHandler';

function startYourHandler() {
  ipcServer.register(IPCNamespaces.YourNamespace, YourHandler);
}

export function startIpcServer() {
  // ...
  startYourHandler();
}
```

#### 3. 在渲染进程调用

```typescript
// packages/renderer/src/main/containers/YourContainer.tsx
const result = await window.api.invoke('YourNamespace.yourMethod', 'param');
console.log(result);
```

### 添加新的 MobX Store

#### 1. 创建 Store

```typescript
// packages/renderer/src/main/stores/YourStore.ts
import { makeAutoObservable, runInAction } from 'mobx';

export class YourStore {
  data: string[] = [];

  constructor() {
    makeAutoObservable(this);
  }

  async loadData() {
    const result = await window.api.invoke('namespace.method');
    runInAction(() => {
      this.data = result;
    });
  }

  addItem(item: string) {
    this.data.push(item);
  }
}
```

#### 2. 注册到全局 Store

```typescript
// packages/renderer/src/main/stores/index.ts
import { YourStore } from './YourStore';

const stores = {
  // ...
  yourStore: new YourStore(),
};

export default stores;
```

#### 3. 在组件中使用

```typescript
import { observer } from 'mobx-react-lite';
import stores from './stores';

const YourComponent = observer(() => {
  const { yourStore } = stores;

  return (
    <div>
      {yourStore.data.map(item => (
        <div key={item}>{item}</div>
      ))}
    </div>
  );
});
```

### 添加新的 Markdown 渲染 Handler

#### 1. 创建 Handler

```typescript
// packages/renderer/src/previewer/handlers/yourHandler.ts
import { visit } from 'unist-util-visit';
import { Root } from 'mdast';

export default function yourHandler(this: any) {
  return (tree: Root) => {
    visit(tree, 'yourNodeType', (node) => {
      // 处理逻辑
      node.type = 'element';
      node.tagName = 'div';
      node.properties = { className: ['your-class'] };
    });
  };
}
```

#### 2. 注册 Handler

```typescript
// packages/renderer/src/previewer/index.ts
import yourHandler from './handlers/yourHandler';

// 在处理器管道中添加
export function createRehypePipeline() {
  return [
    // ...
    yourHandler,
  ];
}
```

### 添加新页面/组件

#### 1. 创建组件文件

```typescript
// packages/renderer/src/components/YourComponent.tsx
import React, { FC } from 'react';
import styles from './YourComponent.module.scss';

interface YourComponentProps {
  title: string;
}

const YourComponent: FC<YourComponentProps> = ({ title }) => {
  return (
    <div className={styles.container}>
      <h1>{title}</h1>
    </div>
  );
};

export default YourComponent;
```

#### 2. 创建样式文件

```scss
// packages/renderer/src/components/YourComponent.module.scss
.container {
  padding: 20px;

  h1 {
    color: #333;
  }
}
```

#### 3. 在其他组件中使用

```typescript
import YourComponent from '/@/components/YourComponent';

<YourComponent title="Hello" />
```

---

## 测试

### 运行测试

```bash
# 运行所有测试
yarn test

# 运行特定包的测试
yarn workspace @onote/electron test
yarn workspace @onote/renderer test

# 运行测试并生成覆盖率报告
yarn test:coverage
```

### 测试类型

1. **单元测试** (Jest)
   - 测试独立函数和组件
   - 位置: `packages/*/src/**/*.test.ts`

2. **E2E 测试** (Cucumber)
   - 测试完整用户流程
   - 位置: `packages/electron/features/`

3. **集成测试**
   - 测试模块间交互
   - IPC 通信测试

### 编写测试

#### 单元测试示例

```typescript
// packages/renderer/src/main/stores/YourStore.test.ts
import { YourStore } from './YourStore';

describe('YourStore', () => {
  it('should initialize with empty data', () => {
    const store = new YourStore();
    expect(store.data).toEqual([]);
  });

  it('should add item', () => {
    const store = new YourStore();
    store.addItem('test');
    expect(store.data).toContain('test');
  });
});
```

---

## 构建与发布

### 构建生产版本

```bash
# 构建所有包
yarn build

# 构建 Electron 应用
yarn compile
```

构建产物位于 `dist/` 目录。

### 打包应用

```bash
# 打包为可执行文件
yarn package

# macOS: 生成 .dmg 和 .zip
# Windows: 生成 .exe 和 .installer
# Linux: 生成 .AppImage, .deb, .rpm
```

### 开发构建

```bash
# 仅构建不打包（更快）
yarn build:dev
```

### 发布新版本

1. **更新版本号**
   ```bash
   # 更新 package.json 中的版本
   npm version patch  # 或 minor, major
   ```

2. **构建和打包**
   ```bash
   yarn build
   yarn package
   ```

3. **创建 Release**
   ```bash
   # 使用 GitHub Release
   # 上传 dist/ 目录中的安装包
   ```

---

## 常见问题

### Q: 依赖安装失败？

**A:** 尝试以下步骤：

```bash
# 清理缓存
yarn cache clean

# 删除 node_modules
rm -rf node_modules packages/*/node_modules

# 重新安装
yarn install
```

### Q: TypeScript 编译错误？

**A:**

```bash
# 清理构建产物
yarn clean

# 重新构建
yarn build
```

如果问题持续，检查：
- TypeScript 版本是否匹配
- `tsconfig.json` 配置是否正确
- 类型定义文件是否存在

### Q: IPC 调用超时？

**A:**

检查：
1. 主进程 Handler 是否正确注册
2. 命名空间和方法名是否正确
3. 主进程是否抛出未捕获的异常
4. 查看主进程和渲染进程的控制台日志

### Q: 热更新不工作？

**A:**

1. 确认开发模式已启动：`yarn dev`
2. 检查 Webpack 配置中的 HMR 设置
3. 尝试手动刷新：`Ctrl+R` 或 `Cmd+R`
4. 重启开发服务器

### Q: Monaco Editor 加载缓慢？

**A:**

1. 检查 Webpack Worker 配置
2. 确认 CDN 资源可访问
3. 考虑本地加载 Worker 文件

### Q: 应用启动失败？

**A:**

1. 查看主进程日志
2. 检查 `packages/electron/src/index.ts` 中的错误
3. 确认所有依赖正确安装
4. 尝试删除 `~/.electron` 缓存

### Q: 如何调试预加载脚本？

**A:**

预加载脚本运行在渲染进程的隔离上下文中：

1. 在预加载脚本中使用 `console.log`
2. 查看渲染进程 DevTools Console
3. 使用 `contextBridge.exposeInMainWorld` 暴露调试函数

---

## 相关文档

- [架构说明](./架构说明.md) - 深入了解系统架构
- [代码规范](./代码规范.md) - 编码标准和最佳实践
- [新手教程](./新手教程.md) - 从零开始学习
- [常见问题](./常见问题.md) - 更多问题解答

---

## 获取帮助

如果遇到文档中没有涵盖的问题：

1. 查看 [GitHub Issues](https://github.com/your-org/ONote/issues)
2. 提交新的 Issue
3. 加入社区讨论

---

## 贡献

欢迎贡献代码！请阅读 [贡献指南](./CONTRIBUTING.md) 了解详情。
